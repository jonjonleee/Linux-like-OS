Buglog for MP3

---CHECKPOINT 1----------
1.
Issue: idt is not loading properly - we can't seem to get the table entries set up

Finding Bug: 1 hour
Fixing Bug: 5 line fix

Solution: We were loading IDTR right next to the place we were loading GDTR inside boot.S.
Instead, since we are separately running an IDT initialization function, we should LIDTR inside init_idt()

2.
Issue: after setting up pic, trying to run bootimg instantly closes the OS and test_debug window

Finding Bug: 1.5 hours
Fixing Bug: 10 lines

Solution: Our PIC implementation was pulled almost entirely from OSDev, and we didn't realize we needed to make some specific modifications.
In the send_eoi() we had to OR irq with EOI to get the right output, and if we are handling the slave, we need to connect the slave to port 2 of the master.
The inb() declarations in the init function were also causing us trouble. We had to find the correct outputs and treat those as defined variables in order to get things working.

3.
Issue: When running test_interrupts() for RTC, it displays only a still image and isn't updating

Finding Bug: 20 minutes
Fixing Bug: 1 line

Solution: We were running test_interrupts() within our test.c file. This only calls the function once, when we want it to call every time RTC
raises an interrupt flag. We have to run test_interrupts() within our rtc_irq_handler() to get the desired effct.

4.
Issue: Warnings for implicit function declarations. We seem to be linking the header files properly but there are still warnings during compilation

Finding Bug: 5 minutes
Fixing Bug: 10 lines

Solution: We weren't sure of the most correct solution, but adding extern function declarations in the necessary header files sufficed to stop the warnings.

5.
Issue: Typing with the keyboard has unpredictable behavior. It breaks after a few types and sometimes outputs the wrong character

Finding Bug: 30 minutes
Fixing Bug: 1 line

Solution: We were sending the EOI signal at the very end of our interrupt handler. Moving send_eoi() to the top of our keyboard_irq_handler()
right after CLI() somehow fixed the issues we were having.

6.
Issue: After setting up paging our video memory was taking up 20kb instead of 4kb

Finding Bug: 20 minutes
Fixing Bug: 10 lines

Solution: As we were looping through the PDT entries, we weren't setting some bits properly. As a result, some pages were initialized
into virtual memory that weren't actually supposed to be initialized.

--------------------------------------------------CHECKPOINT2----------------------------------

7. 
Issue: As we type, the letters appear where they're supposed to, but cursor would either not be updated properly or it would get moved randomly.

Finding Bug: 30 minutes
Fixing Bug 2 lines

Solution: The implementation for oub from OS Dev is slightly different than our because the arguments are swapped. All we had to do was switch the arguments for each outb call and everything worked smoothly. 

8.
Issue: Using the Shift and Control buttons creates undefined behavior because they register presses when the button is both pressed and released.

Finding Bug: 15 minutes
Fixing Bug: 30 minutes

Solution: Since the Shift and Control keys are only active while being held down, they must be handled differently from other keys such as Caps Lock. This involved registering both the pressing and releasing actions of these keys.

9.
Issue: The RTC drives makes the keyboard unresponsive at times, ocassioanlly completely crashing the terminal. 

Finding bug: 1 hour
Fixing bug:  1 line

Solution: The rtc interrupt flag needed to be reset to 0 after waiting for an interrupt.  

10.
Issue: When typing and then backspacing, it doesn't jump to the end of the previous line, it just goes from the right side of the screen

Finding bug: 10 minutes
Fixing bug: 15 lines

Solution: Add an array called line_tracker which tracks the last index of each line, and then when jumping to a previous line we know what to set screen_x to

11.
Issue: Trying to read from directory was repeatedly outputting the same file instead of going through all files in directory

Finding bug: 30 minutes
Fixing bug: 1 line

Solution: The global variable tracking the position in the file was not being updated properly, needed to add # of bytes read after each read

12.
Issue Reading executable from the file system prints everything except the magic numbers at the end

Finding bug: 2 hours
Fixing bug: 20 lines

Solution: The issue wasn't with any of our file system functions, the issue was with the way we were handling prints.
The easiest solution was to just write a helper function to putc everything in buffer to the screen.

--------------------------------------------------CHECKPOINT3----------------------------------

13.
Issue: Upon ls command, all the files are shown in the same line; frequent page faults after reading a text file;

Finding bug: 2 hours
Fixing bug: 10 lines

Solution: We forgot to flush tlb in halt with caused the issue. After implementing flush_tlb function, the program work as intended


14.
Issue: test_debug crashes and becomes unresponsive after a while

Finding bug: 1 hour
Fixing bug: 1 line

Solution: We had to decrement %eax by 1 in systemcall wrapper to make it zero index because jmp table is zero index


15.
Issue: System throws a page fault exception whenever we try to execute any file

Finding bug: 4 hours
Fixing bug: 30 lines

Solution: There was a combination of problems. First, we weren't flushing TLB when transitioning from kernel to user space. We thought this was only necessary when halting.
We also needed to set up a proper mapping to virtual memory for our program pages. We were calculating the index incorrectly


16.
Issue: Arguments for getargs aren't being retrieved properly, seems to always be a few chars off

Finding bug: 30 mins
Fixing bug: 5 lines

Solution: The commands are getting stored along with all of the spaces, enters, tabs, etc.
When calling getargs we need to treat the given command buffer and ignore the first command,
then ignore all of the intermediate spaces in between.
This was done by setting a few flags and doing some basic control flow logic.

17.
Issue: Opening shell runs keeps crashing instantly, throwing some strange exceptions/faults

Finding bug: 1 hour
Fixing bug: 2 lines

Solution: We had messed up the read/write system calls when changing magic numbers into defined variables.
We need to make sure stdin is read only, and stdout is write only. The bounds for valid fd checks were off,
causing the strange functionality.

18.
Issue: Execute function seems to be working on more than just executable files, causing faults

Finding bug: 15 mins
Fixing bug: 5 lines

Solution: Executables start with a unique series of ASCII characters,
as we saw from checkpoint 2 printing executables. We can simply read in the first few characters
from the executable file, and check that the ELF is in the right position. This generally ensures that
the file being exected is actually an executable file (unless the input file is trolling)

--------------------------------------------------CHECKPOINT4----------------------------------

19. 
Issue: Certain executables that use read, such as grep and fish, do not do anything.

Finding bug: 30 mins
Fixing bug: 10 lines

Solution: We were not synchronizing the file descriptor array. Before and after we call the read function, we must
store and update the file information respectively. Before we call read, we need to update the system's file information
(information like opened files and file positions) to the current program's file information. 
Then, after we call read, only the system's information will be updated. Thus, we need to copy back the information
into the PCB so the program remembers all of the relevant file information as well.


--------------------------------------------------CHECKPOINT5----------------------------------

20.
Issue: shell is not running for every terminal when the system first boots up

Finding bug: 5 mins
Fixing bug: 5 ~ 10 lines

Solution: We had to use the on_off_flag in the terminal struct field to make sure we open the scheduled terminal and execute shell in scheduling function

21.
Issue: Wrong calculation of pit frequency led to instability and unpredictable behavior.

Finding the bug: 15 minutes
Fixing the bug: 2 lines

Solution: Set the counter (divider) to 23862 which divides the default frequency (1.1931816666 MHz) and results in 50Hz which is between the ideal range of 10ms to 50ms.

22.
Issue: When we open a new terminal, none of the interrupts are processed and we cannot do anything in the newly 
opened terminal.

Finding bug: 20 mins
Fixing bug: 1 line

Solution: We need to call send_eoi() BEFORE calling scheduler() inside of the pit_handler function because if we 
call it after, the newly executed shell returns to the terminal_switch using esp/ebp stored in execute. Therefore, 
send_eoi() is never reached, and we cannot send any interrupts.

23.
Issue: Infinite page faults after program start

Finding bug: 3 hours
Fixing bug: 10 lines

Solution: The current process info (pid, relevant esp's and ebp's) was not being stored properly. We needed to go through syscalls to make sure everything is stored properly.

24.
Issue: Calling fish was drawing on the incorrect terminal

Finding bug: 4 hours
Fixing bug: 3 lines

Solution: We needed to set the correct vidmap address depending on both the current_terminal and sched_terminal. The format is basically 
the same as from our vidmap system call.

25.
Issue: Scheduler does not terminate programs when switching to a new terminal, so cannot run multiple onging programs at the same time consistently

-Couldn't fix :(